<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">
<META charset="utf-8" />
<HTML>
	<SCRIPT>
		"use strict";
		function range(start, stop, step){
			if (typeof stop=='undefined'){
				// one param defined
				stop = start;
				start = 0;
			};
			if (typeof step=='undefined'){
				step = 1;
			};
			let result = [];
			for (let i=start; step>0 ? i<stop : i>stop; i+=step){
				result.push(i);
			};
			return result;
		};

		function flatten(a) {
			return [].concat.apply([], a);
		}

		function union(a, b) { return [...new Set([...a, ...b])]; }
	
		function popcount(x) {
			x = BigInt(x);
			let m1  = 0x5555555555555555n; //binary: 0101...
			let m2  = 0x3333333333333333n; //binary: 00110011..
			let m4  = 0x0f0f0f0f0f0f0f0fn; //binary:  4 zeros,  4 ones ...
			let m8  = 0x00ff00ff00ff00ffn; //binary:  8 zeros,  8 ones ...
			let m16 = 0x0000ffff0000ffffn; //binary: 16 zeros, 16 ones ...
			let m32 = 0x00000000ffffffffn; //binary: 32 zeros, 32 ones
			let hff = 0xffffffffffffffffn; //binary: all ones
			let h01 = 0x0101010101010101n; //the sum of 256 to the power of 0,1,2,3...
			x = (x & m1 ) + ((x >>  1n) & m1 ); //put count of each  2 bits into those  2 bits 
			x = (x & m2 ) + ((x >>  2n) & m2 ); //put count of each  4 bits into those  4 bits 
			x = (x & m4 ) + ((x >>  4n) & m4 ); //put count of each  8 bits into those  8 bits 
			x = (x & m8 ) + ((x >>  8n) & m8 ); //put count of each 16 bits into those 16 bits 
			x = (x & m16) + ((x >> 16n) & m16); //put count of each 32 bits into those 32 bits 
			x = (x & m32) + ((x >> 32n) & m32); //put count of each 64 bits into those 64 bits 
			return Number(x);
		}

		function powerSet(v) {
			if (new Set(v).size != v.length) {
				throw "duplicate elements";
			}

			let results = [[]];
			for (i = 0; i < v.length; ++i) {
				let temp = results.length;
				for (j = 0; j < temp; ++j) {
					results.push([v[i], ...results[j]]);
				}
			}

			return results;
		}

		var bugs = []
		var changes = []

		// a list (per bug) of lists of bool flags where bit index is index into the changes array
		// array of array of integers
		var state = []

		// same type as states
		var failures = []

		var currentSubset = null;

		function addBug(name) {
			bugs.push(name);
			state.push(range(1, Math.pow(2, changes.length)));
			failures.push([]);
			populateGrid();
		}

		function uiAddBug() {
			let name = prompt("Enter the bug's name.");
			addBug(name);
		}

		function addChange(name) {
			let newIndex = changes.push(name) - 1;
			for (let i = 0; i < bugs.length; ++i) {
				let bugState = state[i];
				let temp = bugState.length;
				let flag = Math.pow(2, newIndex - 1);
				bugState.push(flag);
				for (j = 0; j < temp; ++j) {
					bugState.push(bugState[j] + flag);
				}
			}
			populateGrid();
		}

		function uiAddChange() {
			let name = prompt("Enter the change's name.");
			addChange(name);
		}

		function subsetToIndices(subset) {
				let index = 0;
				let results = []
				while (subset > 0) {
					if (subset & 1) {
						results.push(index);
					}
					subset = subset >> 1;
					++index;
				}
				return results;				
		}

		function indicesToSubset(indices) {
			let result = 0;
			for (let i = 0; i < indices.length; ++i) {
				result |= Math.pow(2, indices[i]);
			}
			return result;
		}

		function subsetListUnion(subsets) {
				let subset = 0
				for (let j = 0; j < subsets.length; ++j) {
					subset = subset | subsets[j];
				}
				return subset;
		}
		
		function getChangeIndicesFromSubsetList(subsets) {
				let subset = 0
				for (let j = 0; j < subsets.length; ++j) {
					subset = subset | subsets[j];
				}
				return subsetToIndices(subsetListUnion(subsets));
		}

		function getBugCandidateSubset(i) {
			return subsetListUnion(state[i]);
		}

		function getBugCandidateChangeIndices(i) {
			return getChangeIndicesFromSubsetList(state[i]);
		}

		function getBugFlattenedResultIndices(i) {
			return getChangeIndicesFromSubsetList(failures[i]);
		}

		function isSubset(a, b) {
			return (a & b) == a;
		}

		function getNextSubset() {
			function oddsOfFailure(subset, bugIndex) {
				return popcount(subset) / popcount(getBugCandidateSubset(bugIndex));
			}

			function getBugSubsetWeights(bugIndex) {
				let bug = state[bugIndex];
				let weights = new Array(bug.length).fill(0)
				for (let i = 0; i < bug.length; ++i) {
					let a = bug[i];
					for (let j = i + 1; j < bug.length; ++j) {
						let b = bug[j]
						if (isSubset(a, b)) { // a is a subset of b
							weights[i] += oddsOfFailure(a, bugIndex); // so if a fails we can remove b, so add the odds of a failing to a's weight
							weights[j] += 1 - oddsOfFailure(b, bugIndex); // and if b passes we can remove a, so add the odds of b passing to b's weight
						}
					}
				}
				return weights;
			}

			function getSubsetWeights() {
				let weights = {}
				for (let i = 0; i < bugs.length; ++i) {
					let bug = state[i];
					let bugWeights = getBugSubsetWeights(i);
					for (let j = 0; j < bugWeights.length; ++j) {
						let subset = bug[j];
						let weight = bugWeights[j];
						if (!(subset in weights)) {
							weights[subset] = 0;
						}
						weights[subset] += weight;
					}
				}
				return weights;
			}

			function getHeaviestSubsets() {
				let weights = getSubsetWeights();
				let heaviestWeight = 0;
				let heaviestSubsets = [];
				for (let subset in weights) {
					if (weights[subset] > heaviestWeight) {
						heaviestWeight = weights[subset];
						heaviestSubsets = [subset];
					} else if (weights[subset] == heaviestWeight) {
						heaviestSubsets.push(subset);
					}
				}
				return heaviestSubsets;
			}

			return Math.min(...getHeaviestSubsets());
		}

		function filterSubsets(passedSubset, bugSubsets) {
			let results = []
			for (let i = 0; i < bugSubsets.length; ++i) {
				if (!isSubset(bugSubsets[i], passedSubset)) {
					results.push(bugSubsets[i]);
				}
			}
			return results;
		}

		function filterSupersets(failedSubset, bugSubsets) {
			let result = []
			for (let i = 0; i < bugSubsets.length; ++i) {
				if (!isSubset(failedSubset, bugSubsets[i])) {
					result.push(bugSubsets[i]);
				}
			}
			return result;
		}

		function onFail(subset, bugIndex) {
			failures[bugIndex] = filterSupersets(subset, failures[bugIndex]);
			failures[bugIndex].push(subset);
			state[bugIndex] = filterSupersets(subset, state[bugIndex]);
		}

		function onPass(subset, bugIndex) {
			state[bugIndex] = filterSubsets(subset, state[bugIndex]);
		}

		function appendButton(parent, html, handler) {
			let element = document.createElement("INPUT");
			element.type = "button";
			element.value = html;
			element.onclick = handler;
			element.style.fontSize = '100%';
			parent.appendChild(element);
			return element;
		}

		function populateGrid() {
			let g = document.getElementById('grid');

			function clear() {
				while (g.rows.length > 0) {
					g.deleteRow(0);
				};
			}

			function dimension() {
				for (let r = 0; r < changes.length + 4; ++r) {
					let row = g.insertRow(r);
					for (let c = 0; c < bugs.length + 4; ++c) {
						row.insertCell(c);
					}
				}
			}

			function setBugsLabel() {
				let v = g.rows[0].cells[3];
				v.colSpan = bugs.length;
				let center = document.createElement('CENTER');
				v.appendChild(center);
				center.innerHTML = "<STRONG>Bugs</STRONG>";
				let add = appendButton(center, "+", uiAddBug);
				add.style.margin = '5px';
			}

			function setChangesLabel() {
				let v = g.rows[2].cells[0];
				v.rowSpan = changes.length + 1;
				v.innerHTML = "<P style='writing-mode: tb-rl'><STRONG>Changes</STRONG></P>";
				let add = appendButton(v, "+", uiAddChange);
				add.style.margin = '5px';
			}

			function setBugHeaders() {
				for (let i = 0; i < bugs.length; ++i) {
					let c = g.rows[1].cells[i + 3]
					c.style.padding = '.2em';
					c.innerHTML = bugs[i];
				}
			}

			function setChangeHeaders() {
				for (let i = 0; i < changes.length; ++i) {
					let c = g.rows[i + 3].cells[1];
					c.style.padding = '.2em';
					c.innerHTML = changes[i];
				}
			}

			function getBugChangeState(bugIndex, changeIndex) {
				let f = failures[bugIndex];
				let bug = state[bugIndex];
				let mask = Math.pow(2, changeIndex);
				let anySureFailure = false;
				let isDone = !isSubset(Math.pow(2, changeIndex), getBugCandidateSubset(bugIndex));
				for (let i = 0; i < f.length; ++i) {
					if (isSubset(mask, f[i])) { // change is in failure i
						let failureCanBeReduced = false;
						for (let j = 0; j < bug.length; ++j) {
							if (!isSubset(mask, bug[j])) {
								if (isSubset(bug[j], f[i])) { // state j is a subset failure i
									failureCanBeReduced = true; // failure i can be reduced to a failure without changeIndex
									isDone = false;
									break;
								}
							}
						}
						if (!failureCanBeReduced) {
							anySureFailure = true;
						}				
					}
				}
				return isDone ?
					(anySureFailure ? "❌" : "✔️") :
					(anySureFailure ? "❓" /* red question mark */: "❔")
			}

			function setBugState(i) {
				for (let j = 0; j < changes.length; ++j) {
					let c = g.rows[j + 3].cells[i + 2]
					c.innerHTML = getBugChangeState(i, j);
				}
			}

			function setBugStates() {
				for (let i = 0; i < bugs.length; ++i) {
					setBugState(i);
				}
			}

			function addBugModifiers(i) {
				let c = g.rows[changes.length + 3].cells[i + 3];
				let edit = appendButton(c, "✎", function() { editBug(i); });
				edit.style.width = '100%';
				c.appendChild(document.createElement('BR'))
				let del = appendButton(c, "🗑", function() { deleteBug(i); });
				del.style.width = '100%'
			}

			function addChangeModifiers(i) {
				let c = g.rows[i + 3].cells[bugs.length + 2];
				// c.style.height = '100%';
				let h = '40px'
				let w = '50px'
				let edit = appendButton(c, "✎", function() { editChange(i); });
				edit.style.height = h;
				edit.style.width = w;
				let up = appendButton(c, "↑", function() { moveChangeDown(i); });
				up.style.height = h;
				up.style.width = w;
				let down = appendButton(c, "↓", function() { moveChangeUp(i); });
				down.style.height = h;
				down.style.width = w;
				let del = appendButton(c, "🗑", function() { deleteChange(i); });
				del.style.height = h;
				del.style.width = w;
			}

			function addModifierButtons() {
				for (let i = 0; i < bugs.length; ++i) {
					addBugModifiers(i);
				}
				for (let i = 0; i < changes.length; ++i) {
					addChangeModifiers(i);
				}
			}

			function setBorders() {
				let bugsCellStyle = g.rows[0].cells[3].style;
				bugsCellStyle.borderLeft = '1px solid black';
				bugsCellStyle.borderRight = '1px solid black';
				bugsCellStyle.padding = '.2em';

				let changesCellStyle = g.rows[2].cells[0].style;
				changesCellStyle.borderTop = '1px solid black';
				changesCellStyle.borderBottom = '1px solid black';

				for (let i = 0; i < bugs.length; ++i) {
					g.rows[1].cells[i + 3].style.border = '1px solid black';
					g.rows[1].cells[i + 3].style.borderBottom = '0px solid black';
					g.rows[changes.length + 3].cells[i + 3].style.borderLeft = '1px solid black';
					g.rows[changes.length + 3].cells[i + 3].style.borderRight = '1px solid black';
				}
				for (let i = 0; i < changes.length; ++i) {
					g.rows[i + 3].cells[bugs.length + 2].style.borderTop = '1px solid black';
					g.rows[i + 3].cells[bugs.length + 2].style.borderBottom = '1px solid black';
					for (let j = -1; j < bugs.length; ++j) {
						g.rows[i + 3].cells[j + 2].style.border = '1px solid black';
					}
				}
			}

			function setBugColors() {
					for (let i = 0; i < bugs.length; ++i) {
						let c = g.rows[1].cells[i + 3]
						c.style.backgroundColor = (currentSubset != null && state[i].includes(currentSubset)) ? 'aquamarine' : '';
					}
			}
			function setChangeColors() {
				let indices = (currentSubset != null) ? subsetToIndices(currentSubset) : null;
				for (let i = 0; i < changes.length; ++i) {
					let c = g.rows[i + 3].cells[1];
					c.style.backgroundColor = (indices != null && indices.includes(i)) ? 'aquamarine' : '';
				}
			}

			clear();
			dimension();
			setBugsLabel();
			setChangesLabel();
			setBugHeaders();
			setChangeHeaders();
			setBugStates();
			setBorders();
			addModifierButtons();
			setBugColors();
			setChangeColors();
		}

		function getPrompt() {
			return document.getElementById('prompt');
		}

		function doNextIteration() {
			currentSubset = getNextSubset();
			prompt();
		}

		function populatePassFailPrompt() {
			let p = getPrompt();
			let indices = subsetToIndices(currentSubset);
			p.innerHTML = "With changes ";
			for (let i = 0; i < indices.length; ++i) {
				if (i > 0) {
					if (i == indices.length - 1) {
						p.innerHTML += " and ";
					} else {
						p.innerHTML += ", ";
					}
				}
				p.innerHTML += "&quot;" + changes[indices[i]] + "&quot;";
			}
			p.innerHTML += " enabled, which bugs were reproducible? Double check your entries before submitting, as errors cannot be corrected.<br>";
			for (let i = 0; i < bugs.length; ++i) {
				if (state[i].includes(currentSubset)) {
					let checkbox = p.appendChild(document.createElement('INPUT'));
					checkbox.type = 'checkbox';
					checkbox.id = 'bug' + i;
					p.innerHTML += bugs[i] + "<br>";
				}
			}
			appendButton(p, "Submit", function() {
				for (let i = 0; i < bugs.length; ++i) {
					let checkbox = document.getElementById('bug' + i);
					if (checkbox) {
						if (checkbox.checked) {
							onFail(currentSubset, i);
						} else {
							onPass(currentSubset, i);
						}
					}
				}
				doNextIteration();
			});
		}

		function populateEnterBugsAndChangesPrompt() {
			let p = getPrompt();
			p.innerHTML = "Use the grid above to enter bug and changes. Once complete, click 'Begin.'<br>";
			appendButton(p, "Begin", doNextIteration)
		}

		function prompt() {
			populateGrid();
			if (currentSubset == null) {
				populateEnterBugsAndChangesPrompt();
			} else {
				populatePassFailPrompt();
			}
			if (true) {
				let p = document.getElementById('debug');
				p.innerHTML += "state = " + JSON.stringify(state) + "<br>";
				p.innerHTML += "failures = " + JSON.stringify(failures) + "<br>";
			}
		}

		function testInit() {
			addChange('u');
			addChange('v');
			addChange('w');
			addChange('x');
			addChange('y');
			addChange('z');
			addBug('a');
			addBug('b');
			addBug('c');
			// addBug('d');
			//addBug('e');
			// state[0] = [0];
			// failures[0] = [1, 2, 3, 16, 17, 18, 19];
			// state = [ [] ];
			// failures = [ [ 1 ] ];
			populateGrid();
		}

		function init() {
			populateGrid();
			testInit();
			prompt();
			//alert(getChangeIndicesFromSubsetList([getNextSubset()]));
		}

		document.addEventListener('DOMContentLoaded', init, false);

	</SCRIPT>
	<HEAD>
		<TITLE>Guided Differential Tester</TITLE>
	</HEAD>
	<STYLE>
		table {
			border-collapse: collapse;
		}
		table, th, td {
			/*border: 1px solid black;*/
			padding: 0;
		}
	</STYLE>
	<BODY>
<!-- 		<INPUT type="checkbox"> Changes are cumulative (e.g. git commits)</INPUT> -->
		<TABLE id="grid" style="font-size: 150%; text-align: center; margin: 1em;">
			<TR>
				<TD>JavaScript must be enabled.</TD>
			</TR>
		</TABLE>
		<P id="prompt" />
		<P id="debug" />
	</BODY>
</HTML>